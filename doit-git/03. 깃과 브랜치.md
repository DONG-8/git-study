# 03.깃과브랜치

고객사에게 다른 버전의 사용 설명서를 제공해야 할 때 발생하는 문제를 브랜치를 통해 해결할 수 있습니다.



## 03-1 브랜치란?

> 모든 버전 관리 시스템에는 '브랜치(branch)' 라는 개념이 있습니다. 브랜치는 원래 나뭇가지라는 뜻이지요.



### 브랜치 기능 살펴보기

깃으로 버전 관리를 시작하면 기본적으로 master 라는 브랜치가 만들어집니다.

사용자가 커밋할 때마다 master 브랜치는 최신 커밋을 가리킵니다.

즉, 브랜치는 커밋을 가리키는 포인터와 비슷하다고 생각하면 됩니다.



### 분기

여기서 분기점을 만들어 기존 master 브랜치를 유지하면서 기존 파일 내용을 수정하거나 새로운 기능을 구현할 파일을 만들 수 있습니다.



### 병합

새 브랜치에서 원하는 작업을 다 끝냈다면 새 브랜치에 있던 파일을 원래 master 브랜치에 합치는 행위



## 03-2 브랜치 만들기

---

### 실습상황 설정하기

1. 터미널 창을 열어 폴더에 새 디렉터리 생성 및 이동

```bash
$ mkdir manual
$ cd manual
```

![image-20211213211339975](03.깃과브랜치.assets/image-20211213211339975.png)

2. `ls -al` 명령어를 사용하여 .git 디렉터리가 만들어졌는지 확인.

![image-20211213213611342](03.깃과브랜치.assets/image-20211213213611342.png)

생성된 모습을 확인할 수 있다.



3. manual 디렉터리 안에 work.txt 파일 만들기



텍스트파일 자체 생성

명령어로 생성

```bash
$ vim work.txt
```

`i` 키 입력을 통해 입력 후 `esc` 를 통해 ex 입력창 들어가기

`:wq` 를 통해 저장 후 종료

![image-20211213214707882](03.깃과브랜치.assets/image-20211213214707882.png)

생성 된 모습을 확인할 수 있다.



4. 방금만든 work.txt 스테이지에 올리고 커밋합니다.

![image-20211213215428767](03.깃과브랜치.assets/image-20211213215428767.png)

Change to be committed 라는 메세지를 통해 스테이징 된 상태 확인

그리고 commit 을 통해

![image-20211213215539536](03.깃과브랜치.assets/image-20211213215539536.png)

unmodified 상태임을 확인

![image-20211213215831365](03.깃과브랜치.assets/image-20211213215831365.png)

###### commit ~~~ : 커밋 해쉬

###### Author : 작성자

###### Date : 작성 날짜

###### work 1 : 커밋 명

이후 2회 더 커밋을 남긴다.(생략)

![image-20211213220207023](03.깃과브랜치.assets/image-20211213220207023.png)

총 3회의 커밋을 완료하였다.

---



### 새 브랜치 만들기

> 이제부터 직접 브랜치를 만들면서 예시 상황을 해결 해 보자.
>
> 현재 상황 : apple, google, ms 라는 고개사가 있다고 가정해 보겠습니다.



#### 브랜치 확인명령

```bash
$ git branch
```

![image-20211213221914708](03.깃과브랜치.assets/image-20211213221914708.png)

master 는 저장소를 만들 때 기본적으로 master 브랜치가 만들어 집니다. 그동안 일반적으로 branch 생성이 없었다면 master 브랜치에서 사용하게 되어 있습니다.



#### 브랜치 생성

```bash
$ git branch 생성할branch이름
```

![image-20211213222219807](03.깃과브랜치.assets/image-20211213222219807.png)

master branch 위에 apple 브랜치가 추가된 것을 확인할 수 있습니다.

master branch 앞에 * 표시는 아직 우리가 master branch 에서 작업하고 있다는 뜻입니다.



**브랜치가 추가된 후에는 커밋 로그 화면도 다르게 나타납니다.** `git log` 를 통해상태 확인을 해 보세용

![image-20211213222634368](03.깃과브랜치.assets/image-20211213222634368.png)

커밋 해쉬 옆 HEAD -> master, apple : apple이 추가 된모습

--> 이 표시는 저장소에 master, apple 2개의 브랜치가 있고, HEAD -> master 이므로 현재 작업중인 브랜치는 master 브랜치라는 의미입니다.



추가적인 branch 생성(생략) : 결과 사진만 첨부

![image-20211213223345680](03.깃과브랜치.assets/image-20211213223345680.png)



#### 브랜치 사이 이동하기  - git check out

> 각 브랜치를 오가면서 작업할 수 있기 위한 명령어

1. `git log` 로 상태 확인

![image-20211213223719798](03.깃과브랜치.assets/image-20211213223719798.png)

work 3 커밋 상태에 3개의 branch 가 생성된 모습을 확인할 수 있다.

```
이 모습은 master 브랜치 뿐만 아니라 ms,google,apple 브랜치에도 최신 커밋이 'wokr 3'라는 뜻입니다.
```



:heavy_check_mark: **현재상태 master branch 에 위치하는중**

2. 또 하나의 수정사항과 commit을 통해 어떻게 변화가 되어지는지 확인!

```bash
$ vim work.txt --> i --> 입력 --> esc --> :wq
$ git commit -am "master content4"
```

![image-20211213224615387](03.깃과브랜치.assets/image-20211213224615387.png)

#### 커밋을 간단히 확인하기 위한 명령

> 한줄에 commit 상태를 확인할 때 좋음

```bash
$ git log --oneline
```

![image-20211213224937163](03.깃과브랜치.assets/image-20211213224937163.png)

master의 경우  master content 4 브랜치에만 적용

이외의 work3 가 최신일 때 생성한 ms, google,apple은 work3 commit 상태에 남아있음



#### 현재 master 브랜치에서 다른 브랜치로 이동했을 때 변동사항 확인

```bash
$ git checkout apple
```

![image-20211213225844085](03.깃과브랜치.assets/image-20211213225844085.png)

Wow!! 변동되었습니다!! 그럼 다시 commit 현황을 확인 해 볼까요??

`git log --oneline` 사용

![image-20211213225947152](03.깃과브랜치.assets/image-20211213225947152.png)

apple branch 최신 commit은 처음 분기될 때인 'work 3 ' commit 그대로 입니다. 그렇다면 work.txt 파일은 어떤 상태일까요?

![image-20211213230314550](03.깃과브랜치.assets/image-20211213230314550.png)

master work4  커밋에서는 content 4 까지 작성 되었던 text가 apple branch로 바뀌면서 work3 commit 상태의 파일로 변경된 모습

```
master 브랜치에서 분기 된 이후에 master 브랜치에 추가된 커밋은 apple 브랜치에 영향을 미치지 않았단 것을 알 수 있습니다.
```



## 03-3 브랜치 정보 확인하기

> 1. 브랜치에서 각각 커밋이 이루어질 때 커밋끼리 어떤 관계를 하고 있는지 확인하는 방법
> 2. 브랜치 사이의 차이점을 확인하는 방법
>
> 을 알아보겠습니다.



#### 새 브랜치에서 커밋하기

1. 현 apple branch 에서 새 commit을 남겨보겠습니다.

```bash
$ vim work.txt --> work.txt에 "apple content 4" 추가 입력 후 저장
```

2. apple 고객사만을 위한 txt 생성

```bash
$ vim apple.txt --> "apple content 4" 추가 입력 후 저장
```

3. 수정 된 2개 파일 add & commit (apple branch 에서 작업 한 상태)

상태 확인

![image-20211213234942127](03. 깃과 브랜치.assets/image-20211213234942127.png)

첫 번째 줄에 HEAD  -> apple 이라고 되어 있으므로  현재 apple 브랜치에 `체크아웃` 한 상태이고

apple 브랜치의 최신 커밋은 'apple content 4'이다.



#### :heavy_check_mark: git log 명령어 : 브랜치 commit 함께보기

```bash
$ git log  --oneline --branches
```

![image-20211213235139067](03. 깃과 브랜치.assets/image-20211213235139067.png)

위의 결과 화면을 통해 어떤 브랜치에서 만든 커밋인지 알 수 있다.

master branch의 최신 커밋 : master content 4

ms, google branch의 최신 커밋 : work 3



#### :heavy_check_mark: 브랜치와 커밋의 관계를 좀더 보기쉽게 그래프 형태로 표시하는 명령어

```bash
$ git log --oneline --branches --graph
```

![image-20211214000407885](03. 깃과 브랜치.assets/image-20211214000407885.png)

- apple 브랜치의 부모 **work 3 커밋** 
- master 브랜치의 부모 **work 3 커밋** 

두 브랜치 모두 work3에서 파생 되었다는 정보를 얻을 수 있다.



#### 브랜치 사이의 차이점 알아보기

> 브랜치 마다 커밋이 쌓여갈수록 브랜치 사이에 어떤 차이가 있는지 일일이 확인하기 어려워진다.
>
> 이럴때는 브랜치 이름 사이에 마침표 두개 `..` 를 넣는 명령으로 차이점을 쉽게 확인할 수 있습니다.
>
>
> 입력법
>
> 1. 브랜치 이릅과 마침표 사이는 공백없이 
> 2. 마침표 왼쪽에 있는 브랜치를 기준으로 오른쪽 브랜치와 비교.

```bash
$ git log master..apple
```

![image-20211214000753135](03. 깃과 브랜치.assets/image-20211214000753135.png)

예시 결과

master 브랜치에는 없고  apple 브랜치에만 있는 커밋, 즉 "apple content 4" 커밋을 보여줍니다.



반대로 했을 때 결과는 "master content 4"가 결과에 나옵니다

![image-20211214000858932](03. 깃과 브랜치.assets/image-20211214000858932.png)



## 03-4 브랜치 병합하기 :red_circle:

> 브랜치 작업을 마무리하고 기존 브랜치와 합해야 합니다.
>
> 이것을 "브랜치 병합(merge)" 이라고 합니다.
>
> 각 여러가지 상황이 생릭 수 잇는데, 각 상황별 병합하는 방법을 알아보겠습니다.
>
> 병합하면서 브랜치 사이에 충돌이 있을 때 해결하는 방법도 함께 살펴봅니다.



### 1. 서로 다른 파일 병합하기



##### 사전준비(병합용 디렉터리 생성)

1. 디렉터리 생성

```bash
$ cd ~
$ git init manual-2
$ cd manual-2
$ ls -al
```

#### git init 디렉터리 이름

> 새로운 디렉터리를 만들고 저장소를 초기화 하는 과정을 한번에 처리가능

```bash
$ git init manual-2 --> 이거
```

![image-20211214001415868](03. 깃과 브랜치.assets/image-20211214001415868.png)

생성 된 모습

![image-20211214001431018](03. 깃과 브랜치.assets/image-20211214001431018.png)

위 4개의 명령어 완료



2.  txt 파일 생성 및 내용추가

```bash
$ vim work.txt --> i --> 입력 --> esc --> :wq (작성저장 및 나가기)
$ git add work.txt
$ git commit -m "work 1"
```



###### 현재 상태

HEAD  -> master -> work 1 : 화살표 순으로 각각을 가리키고 있는 상태



3.  branch 생성

```bash
$ git branch o2
```



###### 현재 상태

HEAD  -> master -> work 1 

​										^

​									o2 가 work 1 커밋을 가리킴



4. master 브랜치에서 파일 추가

```bash
$ vim master.txt
$ git add master.txt
$ git commit -m "master work 2"
```



###### 현재 상태

​	첫 커밋      2번째 커밋 			master가 master work 2 커밋을 가리킴

 work 1  --> master work 2  <--  master <-- HEAD 

​	||

​	o2



5. o2 브랜치로 체크아웃

```bash
$ git checkout o2
```

6. o2 브랜치만의 파일 생성 후 커밋

```bash 
$ vim o2.txt
$ git add o2.txt
$ git commit -m "o2 work 2"
```



###### 현재 상태

​					master : master 브랜치는 master work2 커밋가리킴

​						||

work1  --> master work 2

​			ㄴ--> o2 work 2 

​							||

​							o2 : o2가 o2 work2 커밋을  가리킴

​							||

​							HEAD  : HEAD가 o2 브랜치를 가리킴

7. 현 상태 확인

```bash
$ git log --oneline --branches --graph
```

![image-20211214003156575](03. 깃과 브랜치.assets/image-20211214003156575.png)



8. **o2 브랜치에서 작업이 다 끝났다고 가정하고, o2 브랜치 내용을 master브랜치로 병합합니다**.

```bash
$ git checkout master
```

브랜치 이동

##### 

9. 브랜치 병합을 위해 `git merge`명령 뒤에 가져올 브랜치 이름을 적습니다.

master 브랜치에 o2 브랜치를 가져와 병합하려면다음과 같이 입력

```bash
$ git merge o2
```

![image-20211214003550624](03. 깃과 브랜치.assets/image-20211214003550624.png)

자동으로vim 이 실행되면서 "Merge branch 'o2'" 라는 메세지가 나타납니다.

커밋 메세지를 수정할 수 도 있고, 자동으로 메시지를 그대로 사용해도 됩니다.

여느 ex명령과 동일하게 수행합니다.



###### 현재 상태

​															HEAD : head가 master 브랜치를 가리킴

​																||	

​															master : master 브랜치는 Merge branch o2 커밋가리킴

​																||

work1  --> master work 2  --> Merge branch o2

​			ㄴ--> o2 work 2 --------------^ 

​							||

​							o2 : o2가 o2 work2 커밋을  가리킴

​						

10. ls -al 명령을 사용해 o2에 있던 파일이 mater 브랜치에 합쳐친 모습을 확인할 수 있다.

```bash
$ ls -al
```

![image-20211214003931460](03. 깃과 브랜치.assets/image-20211214003931460.png)

o2.txt는 o2 브랜치에만 있던 것인데 현재 병합 되었다!!



```bash
$ git log --oneline --branches --graph
```

![image-20211214004028946](03. 깃과 브랜치.assets/image-20211214004028946.png)



이처럼 두 브랜치에서 서로 다른 파일을 병합하는 경우 이렇게 깃에서 간단히 해결할 수 있습니다.



#### 추가내용! 빨리감기 병합

새로운 branch를 만들고 master에서 새로운 commit이 없을 때 병합하는 방법

분기한 브랜치에서 최신커밋을 master 브랜치가 가리키게만 하면 되기 때문이지요.

```bash
$ git merge o2
```

```
fast-forward 라는 메세지와 함께 병합됩니다.
이때는 포인터만 움직이는것이기 때문에 commmit 메세지가 나타나지 않습니다.
```



#### 추가내용! 브랜치 병합할 때 편집기 창이 열리지 않게 하기 -- 아까 메세지 수정창

커밋 메세지를 수정하지 않고, 그대로 사용한다면

```bash
$ git merge 브랜치명 --no-edit
```

브랜치를 병합할 때 편집기 창이 나타나지 않도록 설정한 경우, 커밋메세지를 추가하거나 수정하고 싶다면 병합 명령에  --edit 옵션을 사용합니다.

```bash
$ git mergr 브랜치명 --edit
```





### 2. 같은 문서의 다른 위치를 수정했을 때 병합하기

> master 브랜치와 o2 브랜치에 똑같이 work.txt 파일이 있습니다. 양쪽 브랜치에서 work.txt 문서를 수정하되 서로 다른 위치를 수정한 후 브랜치를 병합했을 때 어떤 결과가 나오는지 확인 해 보겠습니다.



**생성 과정에서 work.txt에 2줄의 공백을 두고 같은 내용을 작성하는 것 외에는 똑같이 진행합니다.

![image-20211214005719743](03. 깃과 브랜치.assets/image-20211214005719743.png)

![image-20211214005813583](03. 깃과 브랜치.assets/image-20211214005813583.png)

master와 o2 브랜치를 생성한 모습



1. 양쪽 브랜치 모드에 있는 work.txt를 먼저 master 브랜치에서 수정하겠습니다.

 ```bash
 $ vim work.txt --> (content -> master content 2 수정)
 $ git commit -am "master work 2"
 ```



2. o2 branch로 이동 및 내용 수정

```bash
$ git checkout o2
$ vim work.txt --> (content -> o2 content 2 수정)
$ git commit -am "o2 work 2"
```

3. 양측 커밋이 완료 되었습니다. master 브랜치로 이동

```bash 
$ git checkout master
```

![image-20211214015007385](03. 깃과 브랜치.assets/image-20211214015007385.png)

4. `git merge` 명령을 통해 o2 브랜치를 master 브랜치로 끌어옵니다.

```bash
$ git merge o2
```

![image-20211214015118573](03. 깃과 브랜치.assets/image-20211214015118573.png)

![image-20211214015143455](03. 깃과 브랜치.assets/image-20211214015143455.png)

```
Auto-mergint work.txt
```

라는 병합 완료 메시지가 나타납니다.

5. cat 명령을 통한 내용 확인

```bash
$ cat work.txt
```

오우 합쳐졌네요우!!

![image-20211214015304027](03. 깃과 브랜치.assets/image-20211214015304027.png)

